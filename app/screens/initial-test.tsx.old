import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  Animated,
  Alert,
  ScrollView,
  SafeAreaView,
  Image,
  ImageBackground,
  Easing,
  Dimensions,
  Button,
} from 'react-native';
import { Audio } from 'expo-av';
import { useRouter } from 'expo-router';
import { supabase } from '@src/lib/supabase';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { stageService } from '@src/services/stageService';
import * as FileSystem from 'expo-file-system';
import { StageType } from '@src/types/progress';
import AsyncStorage from '@react-native-async-storage/async-storage';
import aiService from '@src/services/aiService';
import { Platform } from 'react-native';

const SCREEN_WIDTH = Dimensions.get('window').width;

const INTRO_PAGES = [
  {
    title: 'こんにちは！',
    message: 'ぼくは にんじゃの\nしょうねんです！\nいっしょに たのしく べんきょうしようね！',
    backgroundColor: '#FFE0B2',
    image: require('@assets/temp/ninja_syuriken_man.png'),
  },
  {
    title: 'なにをするの？',
    message: 'がめんに でてくる もじを\nよんでみてね！\nきみの よみかたを きかせてね！',
    backgroundColor: '#B2DFDB',
    image: require('@assets/temp/ninja_syuriken_man.png'),
  },
  {
    title: 'どうやるの？',
    message: 'もじが でてきたら\nおおきな こえで よんでね！\nよみおわったら したの ボタンを\nタップしてね！',
    backgroundColor: '#F8BBD0',
    image: require('@assets/temp/ninja_syuriken_man.png'),
  },
  {
    title: 'だいじょうぶ！',
    message: 'はやく よめなくても\nだいじょうぶ！\nゆっくり たのしく\nがんばろうね！',
    backgroundColor: '#C5CAE9',
    image: require('@assets/temp/elder-worried.png'),
  },
  {
    title: 'レッツゴー！ 🌟',
    message: 'わくわく ドキドキ！\nきみの ちからを みせてね！\nいっしょに たのしもう！ 🎉',
    backgroundColor: '#FFD54F',
    image: require('@assets/temp/ninja_syuriken_man.png'),
  },
];

// 全ての拗音のリスト
const YOON_LIST = [
  'きゃ',
  'きゅ',
  'きょ',
  'しゃ',
  'しゅ',
  'しょ',
  'ちゃ',
  'ちゅ',
  'ちょ',
  'にゃ',
  'にゅ',
  'にょ',
  'ひゃ',
  'ひゅ',
  'ひょ',
  'みゃ',
  'みゅ',
  'みょ',
  'りゃ',
  'りゅ',
  'りょ',
  'ぎゃ',
  'ぎゅ',
  'ぎょ',
  'じゃ',
  'じゅ',
  'じょ',
  'びゃ',
  'びゅ',
  'びょ',
  'ぴゃ',
  'ぴゅ',
  'ぴょ',
];

// 濁音・半濁音のリスト
const DAKUON_LIST = [
  'が',
  'ぎ',
  'ぐ',
  'げ',
  'ご',
  'ざ',
  'じ',
  'ず',
  'ぜ',
  'ぞ',
  'だ',
  'ぢ',
  'づ',
  'で',
  'ど',
  'ば',
  'び',
  'ぶ',
  'べ',
  'ぼ',
  'ぱ',
  'ぴ',
  'ぷ',
  'ぺ',
  'ぽ',
];

// 清音のリスト（拗音と濁音・半濁音以外の基本的なひらがな）
const SEION_LIST = [
  'あ',
  'い',
  'う',
  'え',
  'お',
  'か',
  'き',
  'く',
  'け',
  'こ',
  'さ',
  'し',
  'す',
  'せ',
  'そ',
  'た',
  'ち',
  'つ',
  'て',
  'と',
  'な',
  'に',
  'ぬ',
  'ね',
  'の',
  'は',
  'ひ',
  'ふ',
  'へ',
  'ほ',
  'ま',
  'み',
  'む',
  'め',
  'も',
  'や',
  'ゆ',
  'よ',
  'ら',
  'り',
  'る',
  'れ',
  'ろ',
  'わ',
  'を',
  'ん',
];

const IntroPage = ({ page, index }: { page: (typeof INTRO_PAGES)[0]; index: number }) => {
  const bounceAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    // タイトルのバウンスアニメーション
    Animated.loop(
      Animated.sequence([
        Animated.timing(bounceAnim, {
          toValue: -10,
          duration: 800,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
        Animated.timing(bounceAnim, {
          toValue: 0,
          duration: 800,
          easing: Easing.inOut(Easing.quad),
          useNativeDriver: true,
        }),
      ])
    ).start();

    // 最後のページの場合、特別なアニメーション
    if (index === INTRO_PAGES.length - 1) {
      Animated.loop(
        Animated.sequence([
          Animated.timing(scaleAnim, {
            toValue: 1.1,
            duration: 1000,
            useNativeDriver: true,
          }),
          Animated.timing(scaleAnim, {
            toValue: 1,
            duration: 1000,
            useNativeDriver: true,
          }),
        ])
      ).start();

      Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 3000,
          easing: Easing.linear,
          useNativeDriver: true,
        })
      ).start();
    }
  }, []);

  const isLastPage = index === INTRO_PAGES.length - 1;

  return (
    <View
      style={{
        width: SCREEN_WIDTH,
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: page.backgroundColor,
      }}>
      <View
        style={{
          width: '90%',
          height: '90%',
          alignItems: 'center',
          justifyContent: 'space-between',
          paddingVertical: 20,
        }}>
        <Animated.View
          style={{
            backgroundColor: '#FFFFFF',
            borderRadius: 25,
            paddingHorizontal: 30,
            paddingVertical: 15,
            borderWidth: 4,
            borderColor: isLastPage ? '#FF6B6B' : '#FFE500',
            shadowColor: '#000',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.25,
            shadowRadius: 3.84,
            elevation: 5,
            transform: [
              { translateY: bounceAnim },
              { scale: isLastPage ? scaleAnim : 1 },
            ],
          }}>
          <Text
            style={{
              fontSize: isLastPage ? 36 : 32,
              fontFamily: 'Zen-B',
              color: isLastPage ? '#FF6B6B' : '#FF5B79',
              textAlign: 'center',
            }}>
            {page.title}
          </Text>
        </Animated.View>

        <Animated.View
          style={{
            width: '80%',
            height: '40%',
            justifyContent: 'center',
            alignItems: 'center',
            transform: isLastPage ? [
              {
                rotate: rotateAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: ['0deg', '360deg'],
                }),
              },
            ] : [],
          }}>
          <Image
            source={page.image}
            style={{
              width: '100%',
              height: '100%',
            }}
            resizeMode='contain'
          />
          {isLastPage && (
            <>
              <Text style={{
                position: 'absolute',
                fontSize: 40,
                top: -20,
                left: 20,
              }}>✨</Text>
              <Text style={{
                position: 'absolute',
                fontSize: 40,
                bottom: -20,
                right: 20,
              }}>🌟</Text>
              <Text style={{
                position: 'absolute',
                fontSize: 40,
                top: 20,
                right: -10,
              }}>💫</Text>
            </>
          )}
        </Animated.View>

        <View
          style={{
            backgroundColor: '#FFFFFF',
            borderRadius: 20,
            padding: 20,
            width: '90%',
            borderWidth: 3,
            borderColor: isLastPage ? '#FF6B6B' : '#FFE500',
            shadowColor: '#000',
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.25,
            shadowRadius: 3.84,
            elevation: 5,
          }}>
          <Text
            style={{
              fontSize: isLastPage ? 26 : 24,
              fontFamily: 'Zen-B',
              color: '#333333',
              textAlign: 'center',
              lineHeight: isLastPage ? 40 : 36,
            }}>
            {page.message}
          </Text>
        </View>

        <View
          style={{
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'center',
            marginTop: 20,
          }}>
          {INTRO_PAGES.map((_, i) => (
            <Animated.View
              key={i}
              style={{
                width: i === index ? 16 : 12,
                height: i === index ? 16 : 12,
                borderRadius: i === index ? 8 : 6,
                marginHorizontal: 5,
                borderWidth: 2,
                borderColor: isLastPage ? '#FF6B6B' : '#FFE500',
                backgroundColor: i === index ? (isLastPage ? '#FF6B6B' : '#FF5B79') : '#FFFFFF',
                transform: i === index && isLastPage ? [{ scale: scaleAnim }] : [],
              }}
            />
          ))}
        </View>
      </View>
    </View>
  );
};

interface TestResult {
  yoon: string;
  time: number;
  aiResult?: {
    top3?: Array<{
      character: string;
      confidence: number;
    }>;
    isCorrect?: boolean;
    processingTime?: number;
  };
}

export default function InitialTest() {
  const router = useRouter();
  const [currentPage, setCurrentPage] = useState(0);
  const [showIntro, setShowIntro] = useState(true);
  const scrollViewRef = useRef<ScrollView>(null);
  const [recording, setRecording] = useState<Audio.Recording | null>(null);
  const [currentYoon, setCurrentYoon] = useState('');
  const [startTime, setStartTime] = useState<number | null>(null);
  const [remainingYoon, setRemainingYoon] = useState<string[]>([]);
  const [results, setResults] = useState<TestResult[]>([]);
  const [isRecording, setIsRecording] = useState(false);
  const [showResults, setShowResults] = useState(false);
  const [testLevel, setTestLevel] = useState<'beginner' | 'intermediate' | null>(null);
  const [isPaused, setIsPaused] = useState(false);
  const [showEncouragement, setShowEncouragement] = useState(false);
  const [currentEncouragementCount, setCurrentEncouragementCount] = useState(0);
  const fadeAnim = useRef(new Animated.Value(1)).current;
  const [isAIReady, setIsAIReady] = useState(false);
  const [isProcessingAI, setIsProcessingAI] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  const [isTransitioning, setIsTransitioning] = useState(false);

  const scaleAnim = useRef(new Animated.Value(1)).current;
  const speakingAnim = useRef(new Animated.Value(1)).current;
  const characterScale = useRef(new Animated.Value(1)).current;
  const elderFloatAnim = useRef(new Animated.Value(0)).current;
  const encouragementAnim = useRef(new Animated.Value(0)).current;

  // 録音の状態を追跡するフラグを追加
  const [isRecordingUnloaded, setIsRecordingUnloaded] = useState(false);
  
  // 2.5秒タイマーのrefを追加
  const recordingTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // 残りの拗音をrefでも管理（タイマーコールバック内で最新の状態を参照するため）
  const remainingYoonRef = useRef<string[]>([]);
  
  // 録音インスタンスもrefで管理
  const recordingRef = useRef<Audio.Recording | null>(null);
  const startTimeRef = useRef<number | null>(null);
  
  // 現在の拗音もrefで管理（タイマーコールバック内で最新の状態を参照するため）
  const currentYoonRef = useRef<string>('');
  
  // 結果もrefで管理（タイマーコールバック内で最新の状態を参照するため）
  const resultsRef = useRef<TestResult[]>([]);
  
  // カウントダウン表示用のstate（表示しないので不要）
  // const [remainingTime, setRemainingTime] = useState<number>(2.5);
  // const countdownIntervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    // 音声録音の権限を取得と録音開始
    const initializeRecording = async () => {
      await Audio.requestPermissionsAsync();
      
      // AIサービスの初期化
      console.log('AIサービスを初期化中...');
      const aiInitialized = await aiService.initialize();
      if (aiInitialized) {
        console.log('AIサービス初期化成功');
        setIsAIReady(true);
      } else {
        console.log('AIサービス初期化失敗 - モックモードで続行');
        setIsAIReady(true); // モックモードでも続行
      }
      
      // 拗音をシャッフル
      const shuffled = [...YOON_LIST].sort(() => Math.random() - 0.5);
      setRemainingYoon(shuffled);
      remainingYoonRef.current = shuffled;
      setCurrentYoon(shuffled[0]);
      currentYoonRef.current = shuffled[0];
      
      // 初期化完了フラグをセット
      setIsInitialized(true);
    };

    initializeRecording();

    // 喋るアニメーションを開始
    Animated.loop(
      Animated.sequence([
        Animated.timing(speakingAnim, {
          toValue: 1.1,
          duration: 1000,
          useNativeDriver: true,
        }),
        Animated.timing(speakingAnim, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: true,
        }),
      ])
    ).start();

    // 長老のふわふわアニメーション
    Animated.loop(
      Animated.sequence([
        Animated.timing(elderFloatAnim, {
          toValue: 1,
          duration: 2000,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
        Animated.timing(elderFloatAnim, {
          toValue: 0,
          duration: 2000,
          easing: Easing.inOut(Easing.sin),
          useNativeDriver: true,
        }),
      ])
    ).start();

    return () => {
      // コンポーネントのアンマウント時にタイマーをクリアして録音を停止
      if (recordingTimerRef.current) {
        clearTimeout(recordingTimerRef.current);
        recordingTimerRef.current = null;
      }
      if (recordingRef.current) {
        recordingRef.current.stopAndUnloadAsync().catch(() => {
          // エラーを無視
        });
      }
    };
  }, []);

  // showIntroがfalseになったら録音を開始
  useEffect(() => {
    console.log('useEffect triggered:', {
      showIntro,
      showResults,
      isInitialized,
      remainingYoonLength: remainingYoonRef.current.length,
      currentYoon: currentYoonRef.current
    });
    
    if (!showIntro && !showResults && isInitialized && remainingYoonRef.current.length > 0) {
      // 少し遅延を入れて画面遷移を完了させる
      const timer = setTimeout(() => {
        console.log('初回録音を開始します', {
          currentYoon: currentYoonRef.current,
          remainingYoonLength: remainingYoonRef.current.length
        });
        startRecording();
      }, 500);
      
      return () => clearTimeout(timer);
    }
  }, [showIntro, showResults, isInitialized]);

  const startRecording = async () => {
    console.log('startRecording開始', {
      isRecording,
      hasRecording: !!recording,
      currentYoon: currentYoonRef.current,
      remainingYoonLength: remainingYoonRef.current.length,
      isTransitioning
    });
    
    try {
      // 既に録音中の場合は早期リターン
      if (isRecording) {
        console.log('既に録音中のため、新しい録音を開始しません');
        return;
      }
      
      // 遷移中フラグをクリア（念のため）
      setIsTransitioning(false);

      // 既存の録音インスタンスをクリーンアップ
      if (recordingRef.current) {
        try {
          const status = await recordingRef.current.getStatusAsync();
          if (status.isRecording) {
            await recordingRef.current.stopAndUnloadAsync();
          }
        } catch (e) {
          console.log('既存の録音のクリーンアップ中のエラー（無視）:', e);
        }
        setRecording(null);
        recordingRef.current = null;
        
        // 少し待機してから新しい録音を開始
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
      // 録音開始前に必ずフラグをリセット
      setIsRecordingUnloaded(false);

      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      // voiceServiceと同じWAV録音設定を使用
      const recordingOptions: Audio.RecordingOptions = {
        android: {
          extension: '.wav',
          outputFormat: Audio.AndroidOutputFormat.DEFAULT,
          audioEncoder: Audio.AndroidAudioEncoder.DEFAULT,
          sampleRate: 16000,
          numberOfChannels: 1,
          bitRate: 256000,
        },
        ios: {
          extension: '.wav',
          audioQuality: Audio.IOSAudioQuality.HIGH,
          sampleRate: 16000,
          numberOfChannels: 1,
          bitRate: 256000,
          linearPCMBitDepth: 16,
          linearPCMIsBigEndian: false,
          linearPCMIsFloat: false,
        },
        web: {
          mimeType: 'audio/wav',
          bitsPerSecond: 256000,
        },
      };

      const { recording } = await Audio.Recording.createAsync(recordingOptions);

      console.log('録音を開始しました:', currentYoonRef.current);
      
      setRecording(recording);
      recordingRef.current = recording;
      setIsRecording(true);
      const now = Date.now();
      setStartTime(now);
      startTimeRef.current = now;

      // 2.5秒後に自動的に録音を停止するタイマーを設定（表示はしない）
      recordingTimerRef.current = setTimeout(() => {
        console.log('2.5秒経過 - タイマー処理開始');
        // タイマー内で直接次の処理を実行
        handleTimeoutAndMoveNext();
      }, 2500);

      // アニメーション開始
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();
    } catch (err) {
      console.error('録音開始エラー:', err);
      Alert.alert('エラー', '録音を開始できませんでした。');
    }
  };

  const showEncouragementPopover = () => {
    // 現在完了した問題数を計算
    const completedQuestions = YOON_LIST.length - remainingYoon.length;
    // 10の倍数の問題数を設定
    setCurrentEncouragementCount(completedQuestions);

    Animated.spring(encouragementAnim, {
      toValue: 1,
      useNativeDriver: true,
      damping: 15,
      stiffness: 150,
    }).start();
    setShowEncouragement(true);
  };

  const hideEncouragementPopover = () => {
    Animated.timing(encouragementAnim, {
      toValue: 0,
      duration: 200,
      useNativeDriver: true,
    }).start(() => {
      setShowEncouragement(false);
    });
  };

  // タイムアウト時の処理（確実に次の文字へ進む）
  const handleTimeoutAndMoveNext = async () => {
    console.log('handleTimeoutAndMoveNext開始');
    
    // タイマーをクリア
    if (recordingTimerRef.current) {
      clearTimeout(recordingTimerRef.current);
      recordingTimerRef.current = null;
    }
    
    // 録音があれば停止
    if (recordingRef.current) {
      try {
        const status = await recordingRef.current.getStatusAsync();
        if (status.isRecording) {
          await recordingRef.current.stopAndUnloadAsync();
        }
      } catch (e) {
        console.log('録音停止エラー（無視）:', e);
      }
    }
    
    // 状態をリセット
    setIsRecording(false);
    setRecording(null);
    recordingRef.current = null;
    setStartTime(null);
    startTimeRef.current = null;
    setIsRecordingUnloaded(false);
    
    // ダミーの結果を保存（タイムアウトとして）
    const testResult: TestResult = { 
      yoon: currentYoonRef.current, 
      time: 2.5, // タイムアウト時間
      aiResult: undefined // AIは使用しない
    };
    
    const newResults = [...resultsRef.current, testResult];
    setResults(newResults);
    resultsRef.current = newResults;
    
    // 次の文字へ確実に進む
    const currentRemainingYoon = remainingYoonRef.current;
    const newRemaining = currentRemainingYoon.slice(1);
    
    console.log('次の文字へ遷移（タイムアウト）:', {
      現在の文字: currentYoonRef.current,
      次の文字: newRemaining[0],
      残り: newRemaining.length
    });
    
    if (newRemaining.length > 0) {
      // 10問ごとに励ましを表示
      const questionNumber = YOON_LIST.length - newRemaining.length;
      if (questionNumber > 0 && questionNumber % 10 === 0) {
        // 励まし表示の場合も残りの拗音を更新
        setRemainingYoon(newRemaining);
        remainingYoonRef.current = newRemaining;
        setCurrentYoon(newRemaining[0]);
        currentYoonRef.current = newRemaining[0];
        encouragementAnim.setValue(0);
        showEncouragementPopover();
      } else {
        // 直接状態を更新
        setRemainingYoon(newRemaining);
        remainingYoonRef.current = newRemaining;
        setCurrentYoon(newRemaining[0]);
        currentYoonRef.current = newRemaining[0];
        
        // 少し待ってから次の録音を開始
        setIsTransitioning(true);
        setTimeout(() => {
          console.log('次の録音を開始（タイムアウト後）');
          setIsTransitioning(false);
          startRecording();
        }, 500);
      }
    } else {
      // テスト完了
      await saveResults();
    }
  };

  const handleEncouragementContinue = () => {
    hideEncouragementPopover();
    // 既に次の文字は設定されているので、録音を開始するだけ
    console.log('励まし後の録音を開始します:', currentYoonRef.current);
    // アニメーション完了後に録音開始
    setTimeout(() => {
      setIsTransitioning(false);
      startRecording();
    }, 300);
  };

  const stopRecording = async () => {
    // 最初の問題で録音を開始する場合
    if (!isRecording && !recording && results.length === 0) {
      console.log('最初の録音を開始');
      startRecording();
      return;
    }
    
    // 録音がない、または既に処理中の場合はリターン
    if (!recording || !startTime) {
      console.log('stopRecording早期リターン（録音なし）:', { 
        hasRecording: !!recording, 
        hasStartTime: !!startTime,
        isRecording,
        currentYoon: currentYoonRef.current,
        resultsLength: results.length
      });
      
      // 遷移中の場合は何もしない
      if (isTransitioning) {
        console.log('遷移中のため、タップを無視');
        return;
      }
      
      // 録音がまだ開始されていない場合は、タイムアウトとして処理
      if (!isRecording && currentYoonRef.current && remainingYoonRef.current.length > 0) {
        console.log('録音開始前のタップ - タイムアウトとして処理');
        handleTimeoutAndMoveNext();
      }
      return;
    }

    // 既に処理中の場合もリターン（ただしフラグは後で設定）
    if (isRecordingUnloaded) {
      console.log('stopRecording早期リターン（既に処理中）');
      return;
    }

    // すぐにフラグを立てて重複処理を防ぐ
    setIsRecordingUnloaded(true);

    // タイマーをクリア
    if (recordingTimerRef.current) {
      clearTimeout(recordingTimerRef.current);
      recordingTimerRef.current = null;
    }

    try {
      // 時間計測を即座に停止（AI処理時間を含めない）
      const endTime = Date.now();
      const duration = (endTime - startTime) / 1000;

      // 最小時間を0.5秒に制限
      const adjustedDuration = Math.max(duration, 0.5);

      // 録音の状態を確認してから停止
      const recordingStatus = await recording.getStatusAsync();
      if (recordingStatus.isRecording) {
        await recording.stopAndUnloadAsync();
      } else {
        console.log('録音は既に停止しています');
        // 既に停止している場合は、アンロードのみ試行
        try {
          await recording._cleanupForUnloadedRecorder();
        } catch (e) {
          // アンロードエラーは無視
          console.log('アンロード処理スキップ');
        }
      }
      
      // 録音されたファイルのURIを取得
      const audioUri = recording.getURI();
      console.log(`録音完了: ${audioUri}`);
      
      // 録音ファイルの情報を取得してデバッグ
      if (audioUri) {
        try {
          const fileInfo = await FileSystem.getInfoAsync(audioUri);
          console.log('録音ファイル情報:', fileInfo);
        } catch (e) {
          console.error('ファイル情報取得エラー:', e);
        }
      }
      
      // AIで音声認識を実行（時間計測後に実行）
      let aiResult = undefined;
      if (isAIReady && !isProcessingAI && audioUri) {
        setIsProcessingAI(true);
        console.log(`AI音声認識開始: 期待される文字 = ${currentYoonRef.current}, 音声URI = ${audioUri}`);
        
        try {
          // AIサービスのセッションIDを設定（nullに設定してDBへの保存をスキップ）
          aiService.setCurrentSessionId(null);
          
          // 音声認識を実行（期待される結果と録音URIを渡す）
          const classificationResult = await aiService.classifySpeech(currentYoonRef.current, 'beginner', audioUri);
          
          if (classificationResult) {
            console.log('AI認識結果:', {
              character: classificationResult.character,
              confidence: classificationResult.confidence,
              isCorrect: classificationResult.isCorrect,
              top3: classificationResult.top3,
              processingTime: classificationResult.processingTimeMs
            });
            
            // Top-3結果と正解判定を処理
            const CONFIDENCE_THRESHOLD = 0.75;
            const topPrediction = classificationResult.top3?.[0];
            const isHighConfidence = topPrediction ? topPrediction.confidence >= CONFIDENCE_THRESHOLD : false;
            
            aiResult = {
              top3: classificationResult.top3 || [],
              isCorrect: classificationResult.isCorrect !== undefined ? 
                (classificationResult.isCorrect && isHighConfidence) : false,
              processingTime: classificationResult.processingTimeMs
            };
            
            if (classificationResult.top3) {
              console.log(`AI判定詳細: 期待=${currentYoonRef.current}`);
              console.log('Top-3予測:', classificationResult.top3.map((pred, i) => 
                `${i+1}位: ${pred.character} (${(pred.confidence * 100).toFixed(1)}%)`
              ).join(', '));
              console.log(`正解判定: ${aiResult.isCorrect ? '○' : '×'} (閾値: ${CONFIDENCE_THRESHOLD * 100}%)`);
            }
          }
        } catch (aiError) {
          console.error('AI認識エラー:', aiError);
          // エラーが発生してもテストは続行
        } finally {
          setIsProcessingAI(false);
        }
      }

      // 結果を保存（AI結果を含む）
      const testResult: TestResult = { 
        yoon: currentYoonRef.current, 
        time: adjustedDuration, // AI処理時間を含まない純粋な応答時間
        aiResult
      };
      
      const newResults = [...resultsRef.current, testResult];
      setResults(newResults);
      resultsRef.current = newResults;

      // 状態を即座にリセット（重要：次の録音のために必要）
      console.log('録音状態をリセット');
      setIsRecording(false);
      setRecording(null);
      recordingRef.current = null;
      setStartTime(null);
      startTimeRef.current = null;
      setIsRecordingUnloaded(false);
      setIsTransitioning(true); // 遷移中フラグをセット

      // 次の拗音を設定（refから最新の状態を取得）
      const currentRemainingYoon = remainingYoonRef.current;
      const newRemaining = currentRemainingYoon.slice(1);

      console.log('次の文字へ遷移:', {
        現在の文字: currentYoonRef.current,
        次の文字: newRemaining[0],
        残り文字数: newRemaining.length
      });

      if (newRemaining.length > 0) {
        // 10問ごとに励ましを表示
        const questionNumber = YOON_LIST.length - newRemaining.length;
        if (questionNumber > 0 && questionNumber % 10 === 0) {
          // 励まし表示の場合も残りの拗音を更新
          setRemainingYoon(newRemaining);
          remainingYoonRef.current = newRemaining;
          setCurrentYoon(newRemaining[0]);
          currentYoonRef.current = newRemaining[0];
          encouragementAnim.setValue(0); // アニメーション値をリセット
          showEncouragementPopover();
        } else {
          // 状態を更新
          setRemainingYoon(newRemaining);
          remainingYoonRef.current = newRemaining;
          setCurrentYoon(newRemaining[0]);
          currentYoonRef.current = newRemaining[0];
          
          // 少し遅延を入れて確実に前の録音が完了してから次を開始
          setTimeout(() => {
            console.log('次の録音を開始します:', newRemaining[0]);
            setIsTransitioning(false); // 遷移中フラグをクリア
            startRecording();
          }, 500);
        }
      } else {
        // テスト完了
        setIsTransitioning(false);
        await saveResults();
      }
    } catch (err) {
      console.error('録音停止エラー:', err);
      // "already unloaded"エラーは無視する（正常な状態）
      if (err instanceof Error && err.message.includes('already been unloaded')) {
        console.log('録音は既に停止されています（正常）');
        // エラーをユーザーに表示しない
      } else {
        Alert.alert('エラー', '録音を停止できませんでした。');
      }
    } finally {
      // エラーが発生した場合のみ状態をリセット
      if (isRecording || isTransitioning) {
        console.log('finally: エラーのため録音状態をリセット');
        setIsRecording(false);
        setRecording(null);
        recordingRef.current = null;
        setStartTime(null);
        startTimeRef.current = null;
        setIsRecordingUnloaded(false);
        setIsTransitioning(false); // 遷移中フラグもリセット
      }
    }
  };

  const saveResults = async () => {
    try {
      const currentTime = Date.now();
      const { data: sessionData, error: sessionError } = await supabase.auth.getSession();
      if (sessionError) throw sessionError;

      if (!sessionData.session?.user?.id) {
        throw new Error('ユーザーIDが取得できません');
      }

      const userId = sessionData.session.user.id;

      // 仕様書に基づく正答率の計算
      // AI認識結果がある場合はそれを使用、ない場合は時間ベースで判定
      const correctAnswers = results.filter((result) => {
        if (result.aiResult && result.aiResult.isCorrect !== undefined) {
          // AI認識結果を優先
          return result.aiResult.isCorrect;
        } else {
          // フォールバック: 2.5秒以内を正解とする
          return result.time <= 2.5;
        }
      });
      const correctRate = correctAnswers.length / results.length;
      
      // AI認識の統計情報をログ出力
      const aiResults = results.filter(r => r.aiResult);
      console.log('AI認識統計:', {
        総問題数: results.length,
        AI認識実行数: aiResults.length,
        AI正解数: aiResults.filter(r => r.aiResult?.isCorrect).length,
        平均信頼度: aiResults.reduce((sum, r) => sum + (r.aiResult?.confidence || 0), 0) / (aiResults.length || 1)
      });

      // 平均回答時間を計算
      const averageTime = results.reduce((sum, result) => sum + result.time, 0) / results.length;

      // 清音・濁音・拗音ごとの平均時間を計算
      const seionResults = results.filter((r) => SEION_LIST.includes(r.yoon));
      const dakuonResults = results.filter((r) => DAKUON_LIST.includes(r.yoon));
      const yoonResults = results.filter((r) => YOON_LIST.includes(r.yoon));

      const seionAvg = seionResults.length > 0 ? seionResults.reduce((sum, r) => sum + r.time, 0) / seionResults.length : 0;
      const dakuonAvg = dakuonResults.length > 0 ? dakuonResults.reduce((sum, r) => sum + r.time, 0) / dakuonResults.length : 0;
      const yoonAvg = yoonResults.length > 0 ? yoonResults.reduce((sum, r) => sum + r.time, 0) / yoonResults.length : 0;

      // 結果に基づいてレベル判定（添付画像の仕様に従って）
      let determinedLevel;

      if (correctRate >= 1 / 3) {
        // 正答率が1/3以上の場合、中級からスタート
        determinedLevel = 'intermediate';
        setTestLevel('intermediate');
      } else {
        // 正答率が1/3未満の場合、初級からスタート
        determinedLevel = 'beginner';
        setTestLevel('beginner');
      }

      // 結果をストレージに保存
      await AsyncStorage.setItem(
        'initialTestResults',
        JSON.stringify({
          results,
          correctRate,
          averageTime,
          seionAvg,
          dakuonAvg,
          yoonAvg,
          determinedLevel,
          timestamp: currentTime,
        })
      );

      // Supabaseにも結果を保存
      const { error: insertError } = await supabase.from('user_test_results').insert({
        user_id: userId,
        results: JSON.stringify(results),
        correct_rate: correctRate,
        average_time: averageTime,
        seion_avg: seionAvg,
        dakuon_avg: dakuonAvg,
        yoon_avg: yoonAvg,
        determined_level: determinedLevel,
        created_at: new Date().toISOString(),
      });

      if (insertError) throw insertError;

      // initial_test_resultsテーブルの更新
      const { error: updateError } = await supabase.from('initial_test_results').upsert({
        user_id: userId,
        is_completed: true,
        level: determinedLevel,
        completed_at: new Date().toISOString(),
        results: JSON.stringify(results),
      });

      if (updateError) {
        console.error('テスト完了状態の更新エラー:', updateError);
        // エラーログを出すだけで処理は続行
      } else {
        console.log('テスト完了状態を更新しました: is_completed=true, level=' + determinedLevel);
      }

      // user_profilesテーブルのcharacter_levelも更新
      const { error: profileUpdateError } = await supabase
        .from('user_profiles')
        .update({
          character_level: determinedLevel,
        })
        .eq('user_id', userId);

      if (profileUpdateError) {
        console.error('ユーザープロフィールのレベル更新エラー:', profileUpdateError);
      } else {
        console.log('ユーザープロフィールのレベルを更新しました: character_level=' + determinedLevel);
      }

      setShowResults(true);

      // レベルに基づいて初期ステージを設定
      await stageService.initializeStageForUser(userId, determinedLevel === 'beginner' ? StageType.BEGINNER : StageType.INTERMEDIATE);

      // このコメントは削除しない - 以下コメントアウトされた元の遷移コード
      // router.replace('/screens/intermediate');や/screens/beginnerへの遷移をコメントアウト
    } catch (error) {
      console.error('進捗データの保存エラー:', error);
      Alert.alert('エラー', '進捗データの保存に失敗しました');
    }
  };

  const ResultsScreen = () => {
    // AI認識結果を考慮した正解数の計算
    const correctCount = results.filter((r) => {
      if (r.aiResult && r.aiResult.isCorrect !== undefined) {
        return r.aiResult.isCorrect;
      }
      return r.time <= 2.5;
    }).length;
    const accuracy = (correctCount / YOON_LIST.length) * 100;

    // 文字の種類を判定する関数
    const getCharacterType = (char: string) => {
      if (SEION_LIST.includes(char)) return 'せいおん';
      if (DAKUON_LIST.includes(char)) return 'だくおん';
      if (YOON_LIST.includes(char)) return 'ようおん';
      return 'その他';
    };

    // 結果を分類する関数（時間と文字種類を考慮）
    const getTimeCategory = (time: number, char: string) => {
      const charType = getCharacterType(char);

      // 添付画像の仕様に基づいた時間区分
      if (time <= 1.5) {
        // 上級（軽症）
        return { message: 'とてもじょうず！', color: '#4CAF50', bgColor: '#E8F5E9', level: 'じょうきゅう' };
      } else if (time <= 2.0) {
        // 中級
        return { message: 'じょうず！', color: '#2196F3', bgColor: '#E3F2FD', level: 'ちゅうきゅう' };
      } else if (time <= 2.5) {
        // 初級（重症）
        return { message: 'がんばったね', color: '#FF9800', bgColor: '#FFF3E0', level: 'しょきゅう' };
      } else {
        // 2.5秒以上
        return { message: 'もうすこし！', color: '#F44336', bgColor: '#FFEBEE', level: 'しょきゅう' };
      }
    };

    // 10問ごとにグループ化する
    const groupedResults = results.reduce((acc, result, index) => {
      const groupIndex = Math.floor(index / 10);
      if (!acc[groupIndex]) {
        acc[groupIndex] = [];
      }
      acc[groupIndex].push(result);
      return acc;
    }, [] as TestResult[][]);

    return (
      <SafeAreaView style={{ flex: 1, backgroundColor: '#FFFFFF' }}>
        <ScrollView style={{ flex: 1, paddingHorizontal: 20 }}>
          <View style={{ alignItems: 'center', marginBottom: 30, marginTop: 20 }}>
            <Text style={{ fontFamily: 'font-mplus-bold', fontSize: 24, color: '#333', marginBottom: 10 }}>てすとけっか</Text>
            <Text style={{ fontFamily: 'font-mplus-bold', fontSize: 18, color: '#666', marginBottom: 5 }}>
              レベル: {testLevel === 'intermediate' ? 'ちゅうきゅう' : 'しょきゅう'}
            </Text>
          </View>

          {groupedResults.map((group, groupIndex) => (
            <View key={`group-${groupIndex}`} style={{ marginBottom: 30 }}>
              <Text style={{ fontFamily: 'font-mplus-bold', fontSize: 18, color: '#333', marginBottom: 10, textAlign: 'center' }}>
                だい{groupIndex + 1}セット
              </Text>
              <View style={{ marginBottom: 20 }}>
                {group.map((result, index) => {
                  const category = getTimeCategory(result.time, result.yoon);
                  return (
                    <View
                      key={index}
                      style={{
                        backgroundColor: category.bgColor,
                        padding: 15,
                        marginBottom: 8,
                        borderRadius: 12,
                        flexDirection: 'row',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                      }}>
                      <View style={{ flexDirection: 'row', alignItems: 'center', flex: 1 }}>
                        <Text
                          style={{
                            fontFamily: 'font-mplus-bold',
                            fontSize: 24,
                            marginRight: 15,
                            color: '#333',
                          }}>
                          {result.yoon}
                        </Text>
                        <View style={{ flex: 1 }}>
                          <Text
                            style={{
                              fontFamily: 'font-mplus',
                              fontSize: 16,
                              color: category.color,
                            }}>
                            {category.message}
                            {result.aiResult && (
                              <Text style={{ fontSize: 12 }}>
                                {result.aiResult.isCorrect ? ' ✓' : ' ✗'}
                              </Text>
                            )}
                          </Text>
                          <Text
                            style={{
                              fontFamily: 'font-mplus',
                              fontSize: 12,
                              color: '#666',
                            }}>
                            {getCharacterType(result.yoon)}・{category.level}
                          </Text>
                          {result.aiResult?.top3 && result.aiResult.top3.length > 0 && (
                            <View style={{ marginTop: 2 }}>
                              <Text
                                style={{
                                  fontFamily: 'font-mplus',
                                  fontSize: 9,
                                  color: '#999',
                                }}>
                                AI Top-3:
                              </Text>
                              {result.aiResult.top3.slice(0, 3).map((pred, i) => (
                                <Text
                                  key={i}
                                  style={{
                                    fontFamily: 'font-mplus',
                                    fontSize: 8,
                                    color: i === 0 ? '#666' : '#999',
                                  }}>
                                  {i+1}. {pred.character} ({(pred.confidence * 100).toFixed(1)}%)
                                </Text>
                              ))}
                            </View>
                          )}
                        </View>
                      </View>
                      <Text
                        style={{
                          fontFamily: 'font-mplus',
                          fontSize: 14,
                          color: '#666',
                        }}>
                        {result.time.toFixed(2)}秒
                      </Text>
                    </View>
                  );
                })}
              </View>
            </View>
          ))}

          <TouchableOpacity
            onPress={async () => {
              try {
                // 現在のユーザーIDを取得
                const {
                  data: { session },
                } = await supabase.auth.getSession();
                if (!session?.user?.id) {
                  throw new Error('ユーザーIDが取得できません');
                }

                // テストレベルに応じて適切な画面に遷移
                if (testLevel === 'intermediate') {
                  router.replace('/screens/intermediate');
                } else {
                  router.replace('/screens/beginner');
                }
              } catch (error) {
                console.error('画面遷移エラー:', error);
                Alert.alert('エラー', 'つぎの がめんに すすめませんでした');
              }
            }}
            style={{
              backgroundColor: '#41644A',
              padding: 15,
              borderRadius: 8,
              alignItems: 'center',
              marginTop: 20,
              marginBottom: 30,
            }}>
            <Text style={{ color: '#FFF', fontFamily: 'font-mplus-bold', fontSize: 16 }}>つぎへすすむ</Text>
          </TouchableOpacity>
        </ScrollView>
      </SafeAreaView>
    );
  };

  // 一時停止処理
  const handlePause = async () => {
    try {
      // タイマーをクリア
      if (recordingTimerRef.current) {
        clearTimeout(recordingTimerRef.current);
        recordingTimerRef.current = null;
      }
      
      if (recording && !isRecordingUnloaded) {
        await recording.stopAndUnloadAsync();
        setIsRecordingUnloaded(true);
        setIsRecording(false);
        setIsPaused(true);
        // 一時停止した時点でrecordingオブジェクトは再利用できない
      }
    } catch (error) {
      console.error('録音の一時停止中にエラーが発生しました:', error);
      // エラーが発生しても状態は更新する
      setIsRecording(false);
      setIsPaused(true);
      setIsRecordingUnloaded(true);
    }
  };

  // 録音再開処理
  const handleResume = async () => {
    try {
      // 常に新しい録音を開始する
      console.log('新しい録音を開始します');
      await Audio.setAudioModeAsync({
        allowsRecordingIOS: true,
        playsInSilentModeIOS: true,
      });

      const { recording: newRecording } = await Audio.Recording.createAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);

      setRecording(newRecording);
      setIsRecordingUnloaded(false); // 新しい録音なのでフラグをリセット
      setIsRecording(true);
      setIsPaused(false);
      setStartTime(Date.now());

      // 2.5秒後に自動的に録音を停止するタイマーを設定（表示はしない）
      recordingTimerRef.current = setTimeout(() => {
        console.log('2.5秒経過したため、録音を自動停止します');
        stopRecording();
      }, 2500);

      // アニメーション開始
      Animated.sequence([
        Animated.timing(scaleAnim, {
          toValue: 1.1,
          duration: 100,
          useNativeDriver: true,
        }),
        Animated.timing(scaleAnim, {
          toValue: 1,
          duration: 100,
          useNativeDriver: true,
        }),
      ]).start();
    } catch (error) {
      console.error('録音の再開中にエラーが発生しました:', error);
    }
  };

  // 録音完全停止処理
  const handleStop = async () => {
    try {
      // タイマーをクリア
      if (recordingTimerRef.current) {
        clearTimeout(recordingTimerRef.current);
        recordingTimerRef.current = null;
      }
      
      // 録音オブジェクトが存在し、まだアンロードされていない場合のみ停止処理を実行
      if (recording && !isRecordingUnloaded) {
        try {
          await recording.stopAndUnloadAsync();
          setIsRecordingUnloaded(true);
        } catch (unloadError) {
          console.log('録音の停止処理をスキップ:', String(unloadError));
          // エラーを無視して処理を続行
        }
      }

      // 状態をすべてリセット
      setIsRecording(false);
      setIsPaused(false);
      setRecording(null);
      setIsRecordingUnloaded(false); // 次の録音のためにリセット

      // 現在の文字をスキップして次の文字に進む
      const newRemaining = remainingYoon.slice(1);
      if (newRemaining.length > 0) {
        setRemainingYoon(newRemaining);
        remainingYoonRef.current = newRemaining;
        setCurrentYoon(newRemaining[0]);
        currentYoonRef.current = newRemaining[0];
        // 次の文字を表示後に録音を開始
        setTimeout(() => {
          startRecording();
        }, 500);
      } else {
        // テスト完了の場合
        await saveResults();
      }
    } catch (error) {
      console.error('録音の停止中にエラーが発生しました:', error);
      // エラーが発生した場合でも次の文字に進める
      const newRemaining = remainingYoon.slice(1);
      if (newRemaining.length > 0) {
        setRemainingYoon(newRemaining);
        remainingYoonRef.current = newRemaining;
        setCurrentYoon(newRemaining[0]);
        currentYoonRef.current = newRemaining[0];
        setTimeout(() => {
          startRecording();
        }, 500);
      } else {
        await saveResults();
      }
    }
  };

  const handleScroll = (event: any) => {
    const offsetX = event.nativeEvent.contentOffset.x;
    const page = Math.round(offsetX / SCREEN_WIDTH);
    setCurrentPage(page);
  };

  const handleSkip = () => {
    setShowIntro(false);
  };

  const handleStart = () => {
    if (currentPage === INTRO_PAGES.length - 1) {
      setShowIntro(false);
    } else {
      scrollViewRef.current?.scrollTo({
        x: (currentPage + 1) * SCREEN_WIDTH,
        animated: true,
      });
    }
  };

  if (showIntro) {
    return (
      <SafeAreaView style={{ flex: 1 }}>
        <ScrollView
          ref={scrollViewRef}
          horizontal
          pagingEnabled
          showsHorizontalScrollIndicator={false}
          onScroll={handleScroll}
          scrollEventThrottle={16}>
          {INTRO_PAGES.map((page, index) => (
            <IntroPage key={index} page={page} index={index} />
          ))}
        </ScrollView>

        <View
          style={{
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'center',
            paddingHorizontal: 20,
            paddingBottom: 40,
            position: 'absolute',
            bottom: 0,
            left: 0,
            right: 0,
          }}>
          <TouchableOpacity
            style={{
              paddingVertical: 12,
              paddingHorizontal: 24,
              borderRadius: 25,
              backgroundColor: 'rgba(255, 255, 255, 0.8)',
              borderWidth: 2,
              borderColor: '#FFE500',
            }}
            onPress={handleSkip}>
            <Text
              style={{
                fontSize: 18,
                fontFamily: 'Zen-B',
                color: '#666666',
              }}>
              スキップ
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={{
              paddingVertical: 12,
              paddingHorizontal: 40,
              borderRadius: 25,
              backgroundColor: '#00C853',
              borderWidth: 3,
              borderColor: '#FFE500',
              shadowColor: '#000',
              shadowOffset: { width: 0, height: 2 },
              shadowOpacity: 0.25,
              shadowRadius: 3.84,
              elevation: 5,
            }}
            onPress={handleStart}>
            <Text
              style={{
                fontSize: 24,
                fontFamily: 'Zen-B',
                color: '#FFFFFF',
              }}>
              {currentPage === INTRO_PAGES.length - 1 ? 'はじめる' : 'つぎへ'}
            </Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  if (showResults) {
    return <ResultsScreen />;
  }

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <ImageBackground
        source={require('../../assets/temp/doujou.png')}
        style={{
          flex: 1,
          width: '100%',
        }}
        resizeMode='cover'>
        <View
          style={{
            flex: 1,
            paddingHorizontal: 20,
            // backgroundColor: 'rgba(255, 255, 255, 0.85)',
          }}>
          {/* 長老のイラスト */}
          <Animated.Image
            source={require('../../assets/temp/elder-worried.png')}
            style={{
              position: 'absolute',
              top: 20,
              left: 20,
              width: 60,
              height: 60,
              zIndex: 2,
              transform: [
                {
                  translateY: elderFloatAnim.interpolate({
                    inputRange: [0, 1],
                    outputRange: [0, -10],
                  }),
                },
              ],
              opacity: 0.9,
            }}
          />

          {/* 進捗表示 */}
          <View
            style={{
              flexDirection: 'row',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginTop: 80, // 長老の下に表示されるように調整
              marginBottom: 20,
              backgroundColor: 'rgba(255, 255, 255, 0.9)',
              padding: 10,
              borderRadius: 15,
              shadowColor: '#000',
              shadowOffset: { width: 0, height: 2 },
              shadowOpacity: 0.1,
              shadowRadius: 4,
              elevation: 3,
            }}>
            <Text
              style={{
                fontFamily: 'font-mplus-bold',
                fontSize: 18,
                color: '#41644A',
                textShadowColor: 'rgba(255, 255, 255, 0.8)',
                textShadowOffset: { width: 1, height: 1 },
                textShadowRadius: 2,
              }}>
              のこり: {remainingYoon.length} もじ
            </Text>
            <TouchableOpacity onPress={handlePause}>
              <MaterialCommunityIcons name='close' size={24} color='#41644A' />
            </TouchableOpacity>
          </View>

          {/* 一時停止中の表示 */}
          {isPaused && (
            <View
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                justifyContent: 'center',
                alignItems: 'center',
                zIndex: 10,
                paddingHorizontal: 20,
              }}>
              <View
                style={{
                  backgroundColor: 'rgba(255, 255, 255, 0.9)',
                  padding: 30,
                  borderRadius: 25,
                  alignItems: 'center',
                  shadowColor: '#000',
                  shadowOffset: { width: 0, height: 4 },
                  shadowOpacity: 0.1,
                  shadowRadius: 8,
                  elevation: 5,
                }}>
                <Text
                  style={{
                    fontFamily: 'font-mplus-bold',
                    fontSize: 28,
                    color: '#41644A',
                    marginBottom: 30,
                    textAlign: 'center',
                  }}>
                  ていしちゅう
                </Text>
                <View style={{ gap: 16, alignItems: 'center' }}>
                  <TouchableOpacity
                    onPress={handleResume}
                    style={{
                      backgroundColor: '#41644A',
                      paddingHorizontal: 30,
                      paddingVertical: 15,
                      borderRadius: 25,
                      flexDirection: 'row',
                      alignItems: 'center',
                      gap: 8,
                      minWidth: 200,
                      justifyContent: 'center',
                      shadowColor: '#000',
                      shadowOffset: { width: 0, height: 2 },
                      shadowOpacity: 0.2,
                      shadowRadius: 4,
                      elevation: 3,
                    }}>
                    <MaterialCommunityIcons name='play' size={24} color='#FFF' />
                    <Text style={{ color: '#FFF', fontFamily: 'font-mplus-bold', fontSize: 18 }}>さいかい</Text>
                  </TouchableOpacity>

                  <TouchableOpacity
                    onPress={handleStop}
                    style={{
                      backgroundColor: '#E86A33',
                      paddingHorizontal: 30,
                      paddingVertical: 15,
                      borderRadius: 25,
                      flexDirection: 'row',
                      alignItems: 'center',
                      gap: 8,
                      minWidth: 200,
                      justifyContent: 'center',
                      shadowColor: '#000',
                      shadowOffset: { width: 0, height: 2 },
                      shadowOpacity: 0.2,
                      shadowRadius: 4,
                      elevation: 3,
                    }}>
                    <MaterialCommunityIcons name='close-circle' size={24} color='#FFF' />
                    <Text style={{ color: '#FFF', fontFamily: 'font-mplus-bold', fontSize: 18 }}>ちゅうし</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          )}

          {/* 励ましポップオーバー */}
          {showEncouragement && (
            <>
              {/* バックドロップ */}
              <View
                style={{
                  position: 'absolute',
                  top: 0,
                  bottom: 0,
                  left: 0,
                  right: 0,
                  justifyContent: 'center',
                  alignItems: 'center',
                  backgroundColor: 'rgba(0, 0, 0, 0.5)',
                  zIndex: 999,
                }}>
                <Animated.View
                  style={{
                    width: 300,
                    transform: [
                      {
                        scale: encouragementAnim.interpolate({
                          inputRange: [0, 1],
                          outputRange: [0.8, 1],
                        }),
                      },
                    ],
                    opacity: encouragementAnim.interpolate({
                      inputRange: [0, 1],
                      outputRange: [0, 1],
                    }),
                    backgroundColor: 'white',
                    padding: 20,
                    borderRadius: 15,
                    alignItems: 'center',
                    shadowColor: '#000',
                    shadowOffset: { width: 0, height: 2 },
                    shadowOpacity: 0.25,
                    shadowRadius: 4,
                    elevation: 5,
                    zIndex: 1000,
                  }}>
                  <Image source={require('../../assets/temp/elder-worried.png')} style={{ width: 120, height: 120, marginBottom: 10 }} />
                  <Text style={{ fontSize: 24, fontFamily: 'font-mplus-bold', color: '#4CAF50', marginBottom: 10, textAlign: 'center' }}>
                    すごい！
                  </Text>
                  <Text style={{ fontSize: 16, fontFamily: 'font-mplus', color: '#666', textAlign: 'center', marginBottom: 20 }}>
                    {currentEncouragementCount}もんめ おわったよ！{'\n'}このちょうしで がんばろう！
                  </Text>
                  <TouchableOpacity
                    onPress={handleEncouragementContinue}
                    style={{
                      backgroundColor: '#4CAF50',
                      paddingVertical: 10,
                      paddingHorizontal: 30,
                      borderRadius: 25,
                    }}>
                    <Text style={{ color: 'white', fontSize: 18, fontFamily: 'font-mplus-bold' }}>つぎへ</Text>
                  </TouchableOpacity>
                </Animated.View>
              </View>
            </>
          )}

          {/* 拗音表示 */}
          <View
            style={{
              flex: 1,
              justifyContent: 'center',
              alignItems: 'center',
            }}>
            {/* 文字の背景円 */}
            <View
              style={{
                position: 'absolute',
                width: '80%',
                height: 240,
                borderRadius: 24,
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                justifyContent: 'center',
                alignItems: 'center',
                shadowColor: '#000',
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.2,
                shadowRadius: 8,
                elevation: 5,
              }}
            />

            <Animated.Text
              style={{
                fontFamily: 'font-mplus-bold',
                fontSize: 120,
                color: '#333',
                transform: [{ scale: characterScale }],
                textShadowColor: 'rgba(255, 255, 255, 0.8)',
                textShadowOffset: { width: 2, height: 2 },
                textShadowRadius: 4,
              }}>
              {currentYoon}
            </Animated.Text>
          </View>

          {/* 録音ボタン */}
          <View
            style={{
              alignItems: 'center',
              marginBottom: 40,
              backgroundColor: 'rgba(255, 255, 255, 0.9)',
              padding: 20,
              borderRadius: 20,
              shadowColor: '#000',
              shadowOffset: { width: 0, height: 2 },
              shadowOpacity: 0.1,
              shadowRadius: 4,
              elevation: 3,
            }}>
            {/* カウントダウン表示は削除（子供を急かさないため） */}
            <TouchableOpacity
              onPress={stopRecording}
              disabled={isProcessingAI || isTransitioning || (!isRecording && results.length > 0)}
              style={{
                width: 120,
                height: 120,
                borderRadius: 60,
                backgroundColor: isProcessingAI || isTransitioning || (!isRecording && results.length > 0) ? '#999' : (isRecording ? '#E86A33' : '#41644A'),
                justifyContent: 'center',
                alignItems: 'center',
                shadowColor: '#000',
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.3,
                shadowRadius: 5,
                elevation: 6,
              }}>
              {isProcessingAI || isTransitioning ? (
                <MaterialCommunityIcons name='dots-horizontal' size={60} color='#FFF' />
              ) : isRecording ? (
                <MaterialCommunityIcons name='stop' size={60} color='#FFF' />
              ) : (
                <MaterialCommunityIcons name='microphone' size={60} color='#FFF' />
              )}
            </TouchableOpacity>
            <Text
              style={{
                fontFamily: 'font-mplus',
                fontSize: 16,
                color: '#41644A',
                marginTop: 10,
                textShadowColor: 'rgba(255, 255, 255, 0.8)',
                textShadowOffset: { width: 1, height: 1 },
                textShadowRadius: 2,
              }}>
              {isProcessingAI ? 'しょりちゅう...' : (isTransitioning ? 'じゅんびちゅう...' : (isRecording ? 'よみおわったら タップ' : (results.length === 0 ? 'たっぷして すたーと' : 'じゅんびちゅう...')))}
            </Text>
            {isAIReady && (
              <Text
                style={{
                  fontFamily: 'font-mplus',
                  fontSize: 12,
                  color: '#999',
                  marginTop: 5,
                }}>
                AI {isAIReady ? 'じゅんびOK' : 'じゅんびちゅう'}
              </Text>
            )}
          </View>
        </View>
      </ImageBackground>
    </SafeAreaView>
  );
}
